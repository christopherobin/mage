# Panopticon

## Introduction

Panopticon is a node.js utility to aggregate samples generated by a node.js
application. It works in regular, single instance applications as well as
applications that make use of the `cluster` core module. Samples generated
by all processes are sent to the master process and emitted so that the
aggregated data may be used.

In order to minimise parsing load due to interprocess communication, data is
sub-aggregated on each machine for an interval, and then forwarded to the master
for final aggregation, reducing the parsing load to a single object per machine
per instance, rather than parsing a small object for every sample taken.

## Usage

Require panopticon like a regular node.js module:

```javascript
var Panopticon = require('panopticon');
```

Panopticon itself is a constructor, so when you're ready to start it, make a new
object

```javascript
var panopticon = new Panopticon(startTime, interval);
```

where startTime (ms since the unix epoch) is an optional time to start from, and
interval is the time delay (in ms) between batches of data. If no start time is
provided, then it defaults to 0. Similarly, if no sane interval is provided, it
interval defaults to 10 seconds.

It is important to note that for consistent sample collection, when startTime
is given it must be the same across all workers and the master.

By default the PID of each worker and the master are logged, as well as the
number of workers (not including the master). Everything else needs to be sent
to the panopticon object using one of its acquisition methods. In each case the
`id` is the identifier that should be associated with this piece of data. The
methods are

 - `panopticon.set(id, n)`, where 'n', a finite number, may replace a previous
   `n` for this `id`.
 - `panopticon.set(id, n)`, where 'n' is added to the previous value if 'n' is
    a finite number. If `n` is not a finite number, then it defaults to 1.
 - `panopticon.sample(id, n)` Keeps track of the max, min, average and standard
    deviation of `n` over an interval.

When your application is shutting down, it should call `panopticon.stop()` to
clear timers.

On the master, halfway between collections from the workers and itself the
panopticon object emits aggregated data. This *only happens on the master*.

```javascript
if (cluster.isMaster) {
	panopticon.on('delivery', function (aggregatedData) {
		// Do something with aggregatedData
	});
}
```

## Points to note

The node.js implementation of setTimeout is buggy. The resulting timeout can
(and does) fire early sometimes, contrary to expectations. This lead to some
acrobatics to ensure that when it does fire early, it is reinitialised. This
can be seen in `Panopticon.prototype.timeUp`.